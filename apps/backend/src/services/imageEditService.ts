import { GoogleGenAI } from "@google/genai";
import { GOOGLE_GEMINI_API_KEY, IMAGE_EDIT_TIMEOUT } from "../config";


interface ImageEditRequest {
  image: string; // Base64 encoded image (with or without data URL prefix)
  prompt: string; // Natural language editing instruction
  negativePrompt?: string; // Optional: what to avoid in the edit
}

interface ImageEditResponse {
  success: boolean;
  editedImage?: string; // Base64 encoded edited image
  error?: string;
}

/**
 * Converts a data URL or base64 string to pure base64 (without prefix)
 */
function toBase64(dataUrl: string): string {
  if (dataUrl.startsWith("data:")) {
    // Extract base64 from data URL
    const base64Index = dataUrl.indexOf("base64,");
    if (base64Index !== -1) {
      return dataUrl.substring(base64Index + 7);
    }
  }
  // Already base64
  return dataUrl;
}


/**
 * Edit an image using Gemini 2.5 Flash Image API
 */
export async function editImageWithGemini(
  request: ImageEditRequest,
): Promise<ImageEditResponse> {
  try {
    console.log("[ImageEditService] Starting image edit with Gemini 2.5 Flash Image");
    console.log("[ImageEditService] Prompt:", request.prompt);

    // Validate API key
    if (!GOOGLE_GEMINI_API_KEY) {
      console.error(
        "[ImageEditService] Google Gemini API key not configured",
      );
      return {
        success: false,
        error:
          "Google Gemini API key not configured. Please set GOOGLE_GEMINI_API_KEY in your environment.",
      };
    }

    // Initialize Gemini client
    const ai = new GoogleGenAI({ apiKey: GOOGLE_GEMINI_API_KEY });

    // Convert image to base64 (without data URL prefix)
    const base64Image = toBase64(request.image);
    console.log(
      `[ImageEditService] Image base64 length: ${base64Image.length} characters`,
    );

    // Prepare the prompt with image for editing
    const contents = [
      {
        text: request.prompt,
      },
      {
        inlineData: {
          mimeType: "image/png",
          data: base64Image,
        },
      },
    ];

    // Call Gemini API with timeout
    const timeoutPromise = new Promise((_, reject) =>
      setTimeout(
        () => reject(new Error("Request timed out")),
        IMAGE_EDIT_TIMEOUT,
      ),
    );

    console.log("[ImageEditService] Sending request to Gemini API...");
    const responsePromise = ai.models.generateContent({
      model: "gemini-2.5-flash-image",
      contents: contents,
    });

    const response: any = await Promise.race([
      responsePromise,
      timeoutPromise,
    ]);

    console.log("[ImageEditService] Received response from Gemini");

    // Extract the edited image from response
    if (!response.candidates || response.candidates.length === 0) {
      console.error(
        "[ImageEditService] No candidates in response:",
        response,
      );
      return {
        success: false,
        error: "No image generated by Gemini API",
      };
    }

    const parts = response.candidates[0].content.parts;
    let editedImageBase64: string | null = null;

    // Look for inline image data in response
    for (const part of parts) {
      if (part.text) {
        console.log("[ImageEditService] Gemini text response:", part.text);
      } else if (part.inlineData) {
        // Found the edited image
        editedImageBase64 = part.inlineData.data;
        console.log(
          "[ImageEditService] Found edited image in response",
        );
        break;
      }
    }

    if (!editedImageBase64) {
      console.error(
        "[ImageEditService] No image data found in response",
      );
      return {
        success: false,
        error: "No image data in Gemini response",
      };
    }

    // Convert to data URL format
    const dataUrl = `data:image/png;base64,${editedImageBase64}`;
    console.log("[ImageEditService] Successfully edited image with Gemini");

    return {
      success: true,
      editedImage: dataUrl,
    };
  } catch (error: any) {
    if (error.message === "Request timed out") {
      console.error(
        "[ImageEditService] Request timed out after",
        IMAGE_EDIT_TIMEOUT,
        "ms",
      );
      return {
        success: false,
        error: "Request timed out. The image editing service is taking too long to respond.",
      };
    }

    // Handle API quota errors
    if (error.message && error.message.includes("quota")) {
      console.error("[ImageEditService] API quota exceeded:", error.message);
      return {
        success: false,
        error: "API quota exceeded. Please try again later.",
      };
    }

    // Handle authentication errors
    if (error.message && error.message.includes("API key")) {
      console.error("[ImageEditService] API key error:", error.message);
      return {
        success: false,
        error: "Invalid API key. Please check your configuration.",
      };
    }

    console.error("[ImageEditService] Error editing image:", error);
    return {
      success: false,
      error: error.message || "Unknown error occurred during image editing",
    };
  }
}

// Backward compatibility export
export const editImageWithQwen = editImageWithGemini;
